get_ocp_channel () {
    local channel=$(oc get clusterversion -o json | jq -r '.items[0].spec.channel' | sed -r -n 's/.*-(.*)/\1/p')
    echo ${channel}
}

pause_mcp () {
    ECHO skip oc patch --type=merge --patch='{"spec":{"paused":true}}' machineconfigpool/${MCP}
}

resume_mcp () {
    ECHO resume_mcp skip: oc patch --type=merge --patch='{"spec":{"paused":false}}' machineconfigpool/${MCP}
}

# return True if either worker or my mcp is still updating.
get_mcp_progress_status () {
    local my_mcp_status=True
    local worker_status=$(oc get mcp worker -o json | jq -r '.status.conditions[] | select(.type == "Updated") | .status')
    if oc get mcp ${MCP} &> /dev/null ; then
        # my mcp exists.
        my_mcp_status=$(oc get mcp ${MCP} -o json | jq -r '.status.conditions[] | select(.type == "Updated") | .status')
    fi
    if [ "$worker_status" == "False" ]  || [ "$my_mcp_status" == "False" ]; then
        echo "True"
        # still updating
    else
        # All done updating
        echo "False"
    fi
}

wait_mcp () {
    resume_mcp
    printf "waiting 30 secs before checking mcp status "
    local count=30
    while [[ $count -gt 0  ]]; do
        sleep 10
        printf "."
        count=$((count-10))
    done

    local status=$(get_mcp_progress_status)
    count=300
    printf "\npolling 3000 sec for mcp complete"
    while [[ $status != "False" ]]; do
        if ((count == 0)); then
            printf "\ntimeout waiting for mcp complete on the baremetal host!\n"
            exit 1
        fi
        count=$((count-1))
        printf "."
        sleep 10
        status=$(get_mcp_progress_status)
    done
    printf "\nmcp complete on the baremetal host in %d sec\n" $(( (300-count) * 10 ))
}

wait_pod_in_namespace () {
    local namespace=$1
    local count=100
    printf "waiting for pod in ${namespace}"
    while ! oc get pods -n ${namespace} 2>/dev/null | grep Running; do
        if ((count == 0)); then
            printf "\ntimeout waiting for pod in ${namespace}!\n" 
            exit 1
        fi
        count=$((count-1))
        printf "."
        sleep 5
    done
    printf "\npod in ${namespace}: up\n"
}

wait_named_pod_in_namespace () {
    local namespace=$1
    local podpattern=$2
    local count=100
    printf "waiting for pod ${podpattern} in ${namespace}"
    while ! oc get pods -n ${namespace} 2>/dev/null | grep ${podpattern} | grep Running; do
        if ((count == 0)); then
            printf "\ntimeout waiting for pod ${podpattern} in ${namespace}!\n"
            exit 1
        fi
        count=$((count-1))
        printf "."
        sleep 5
    done
    printf "\npod ${podpattern} in ${namespace}: up\n"
}

wait_named_deployement_in_namespace () {
    local namespace=$1
    local deployname=$2
    local count=100
    printf "waiting for deployment ${deployname} in ${namespace}"
    local status="False"
    while [[ "${status}" != "True" ]]; do
        if ((count == 0)); then
            printf "\ntimeout waiting for deployment ${deployname} in ${namespace}!\n"
            exit 1
        fi
        count=$((count-1))
        printf "."
        sleep 5
        status=$(oc get deploy ${deployname} -n ${namespace} -o json 2>/dev/null | jq -r '.status.conditions[] | select(.type=="Available") | .status' || echo "False")
    done
    printf "\ndeployment ${deployname} in ${namespace}: up\n"
}

exec_over_ssh () {
    local nodename=$1
    local cmd=$2
    local ssh_options="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    local ip_addr=$(oc get node ${nodename} -o json | jq -r '.status.addresses[0] | select(.type=="InternalIP") | .address')
    local ssh_output=$(ssh ${ssh_options} core@${ip_addr} "$cmd")
    echo "${ssh_output}"
}

parse_args() {
    USAGE="Usage: $0 [options]
Options:
    -n             Do not wait
    -h             This
"
    while getopts "hn" OPTION
    do
        case $OPTION in
            n) WAIT_MCP="false" ;;
            h) echo "$USAGE"; exit ;;
            *) echo "$USAGE"; exit 1;;
        esac
    done

    MCP=${MCP:-"worker-nas"}
    WAIT_MCP=${WAIT_MCP:-"true"}
    WORKERS=${WORKERS:-"none"}
    if [ ${WORKERS} == "none" ]; then 
        WORKERS=$(oc get node | grep worker | awk '{print $1}')
    fi
}


add_label_workers () {
    for worker in $WORKERS; do
        oc label --overwrite node ${worker} node-role.kubernetes.io/${MCP}=""
    done
}

remove_label_workers () {
    for worker in $WORKERS; do
        oc label --overwrite node ${worker} node-role.kubernetes.io/${MCP}-
    done
}


function ver { 
   printf "%03d%03d%03d%03d" $(echo "$1" | tr '.' ' '); 
}

hn_echo() {
    echo $@
}
hn_exit() {
    echo "HN exit"
    exit
}

function prompt_continue {
    printf 'Continue next step (y/n)? '
    if [ "${SINGLE_STEP}" != "true" ]; then
        return
    fi
    read answer
    if [ "$answer" != "${answer#[Yy]}" ] ;then 
        echo Yes
    else
        echo No
        exit 1
    fi

}

function ECHO {
	echo ECHO: $@
}

DPRINT() {
  if [ "$DEBUG" == 1 ]; then
     printf "($1): $2\n" 
  fi
}

bind_driver () {
    local driver=$1
    local pci=$2
    DPRINT $LINENO "pci-=$pci"
    local original_path=$(realpath /sys/bus/pci/devices/${pci}/driver)
    DPRINT $LINENO "original_path=$original_path"
    prompt_continue

    local new_path=/sys/bus/pci/drivers/${driver}
    if [[ ! -e ${new_path}/${pci} ]]; then
        echo ${pci} > ${original_path}/unbind  || true
        echo ${driver} > /sys/bus/pci/devices/${pci}/driver_override  || true
        echo ${pci} > ${new_path}/bind  || true
        if [[ ! -e ${new_path}/${pci} ]]; then
            echo "failed to bind ${pci} to ${new_path}"
            exit 1
        fi
    fi
}


bind_driver () {
    local driver=$1
    local pci=$2
    DPRINT $LINENO "Attempting to bind ${pci} to ${driver}"

    # Check if the device has a currently bound driver
    local driver_path="/sys/bus/pci/devices/${pci}/driver"
    if [[ -e ${driver_path} ]]; then
        local current_driver=$(basename "$(realpath ${driver_path})")
        DPRINT $LINENO "Current driver for ${pci} is ${current_driver}, unbinding..."
        echo "${pci}" > "/sys/bus/pci/drivers/${current_driver}/unbind" || {
            echo "Failed to unbind current driver from ${pci}"
            exit 1
        }
        sleep 1  # Allow time for unbind to take effect
    else
        DPRINT $LINENO "No driver bound to ${pci}, skipping unbind"
    fi

    # Check if driver_override exists and is writable
    if [[ ! -w "/sys/bus/pci/devices/${pci}/driver_override" ]]; then
        echo "Error: driver_override is not writable for ${pci}"
        exit 1
    fi

    # Override the driver with vfio-pci
    echo "${driver}" > "/sys/bus/pci/devices/${pci}/driver_override" || {
        echo "Failed to set driver_override for ${pci}"
        exit 1
    }

    # Bind the device to vfio-pci
    echo "${pci}" > "/sys/bus/pci/drivers/vfio-pci/bind" || {
        echo "Failed to bind ${pci} to vfio-pci"
        exit 1
    }

    # Check if binding was successful
    if [[ -e ${driver_path} ]] && [[ "$(basename "$(realpath ${driver_path})")" == "${driver}" ]]; then
        DPRINT $LINENO "Successfully bound ${pci} to ${driver}"
    else
        echo "Failed to bind ${pci} to ${driver}"
        exit 1
    fi
}



